## ë¬¸ì œ íŒŒì•…

- S â†’ L â†’ E ë¡œ ê°€ëŠ” ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤.

![image.png](../img/img18.png)

## ì ‘ê·¼ ë°©ë²•

- BFS íƒìƒ‰ 2ë²ˆ ì‹¤í–‰
    1. S â†’ L ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ íƒìƒ‰í•˜ëŠ” ì²« ë²ˆì§¸ BFS ì‹¤í–‰í•œë‹¤.
    2. L â†’ E ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ íƒìƒ‰í•˜ëŠ” ë‘ ë²ˆì§¸ BFS ì‹¤í–‰
    3. ë‘ ê±°ë¦¬ì˜ í•©ì„ ìµœì¢… ë°˜í™˜í•˜ê³ , ë§Œì•½ í•˜ë‚˜ë¼ë„ ë„ì°©í•  ìˆ˜ ì—†ë‹¤ë©´ -1ì„ ë°˜í™˜í•œë‹¤.

- ì£¼ì–´ì§„ mapsëŠ” ë¬¸ìì—´ ë°°ì—´ì´ë¯€ë¡œ chartAt()ë¡œ ë¬¸ìë¥¼ íƒìƒ‰í•œë‹¤.

## ì½”ë“œ êµ¬í˜„

ğŸ’ŸÂ S â†’ L â†’ E ì˜ ìµœë‹¨ ê²½ë¡œ BFS íƒìƒ‰
- BFS í•¨ìˆ˜ ì¸ìë¡œ visited ì „ë‹¬
- dist ë°°ì—´ë¡œ ë¶„ë¦¬

```angular2html
import java.util.*;

class Solution {
    static int[] dx = {0,0,-1,1};
    static int[] dy = {1,-1,0,0};
    static int m, n;
    
    public int solution(String[] maps) {
        m = maps.length;
        n = maps[0].length();
        
        int sx = 0, sy = 0;
        int lx = 0, ly = 0;
        
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                char c = maps[i].charAt(j);
                if(c == 'S'){
                    sx = i;
                    sy = j;
                } else if(c == 'L'){
                    lx = i;
                    ly = j;
                }
            }
        }
        
        int d1 = BFS(maps, new boolean[m][n], sx, sy, 'L');
        if(d1 == -1) return -1;
        
        int d2 = BFS(maps, new boolean[m][n], lx, ly, 'E');
        if(d2 == -1) return -1;
        
        return d1 + d2;
        
    }
    
    private int BFS(String[] maps, boolean[][] visited, int sx, int sy, char ch){
        Queue<int[]> queue = new ArrayDeque<>();
        int[][] dist = new int[m][n];
        queue.offer(new int[]{sx,sy});
        visited[sx][sy] = true;
        dist[sx][sy] = 0;
        
        while(!queue.isEmpty()){
            int[] cur = queue.poll();
            int x = cur[0], y = cur[1];
            
            for(int d = 0; d < 4; d++){
                int nx = x + dx[d];
                int ny = y + dy[d];
                
                if(nx >= 0 && nx < m && ny >= 0 && ny < n){
                    if(maps[nx].charAt(ny) != 'X' && !visited[nx][ny]){
                        visited[nx][ny] = true;
                        dist[nx][ny] = dist[x][y] + 1;
                        
                        if(maps[nx].charAt(ny) == ch) return dist[nx][ny];
                        
                        queue.offer(new int[]{nx, ny});
                    }
                }
            }
        }
        return -1;
    }
}
```