## ë¬¸ì œ íŒŒì•…

![image.png](../img/img12.png)

## ì ‘ê·¼ ë°©ë²•

- ì£¼ì–´ì§„ vertexëŠ” ì—°ê²°ëœ ë‘ ì •ì ì´ ë¦¬ìŠ¤íŠ¸ì´ë‹¤. ì¦‰, ê°„ì„  ëª©ë¡ í˜•íƒœì´ë¯€ë¡œ, HashMapì„ ì‚¬ìš©í•˜ì—¬ ì¸ì ‘ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜í•œë‹¤.
- ëª¨ë“  ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ëŠ” ê°™ê³ , ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•´ì•¼ í•˜ë¯€ë¡œ BFSë¥¼ ìˆ˜í–‰í•œë‹¤.
- BFS í•¨ìˆ˜ì—ì„œëŠ” ê° ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ ì €ì¥í•œ ë°°ì—´ì´ í•„ìš”í•˜ë¯€ë¡œ, voidê°€ ì•„ë‹Œ int[]ë¥¼ ë°˜í™˜í•˜ë„ë¡ í•œë‹¤.
- BFSë¥¼ í†µí•´ 1ë²ˆ ë…¸ë“œë¡œë¶€í„° ê° ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•œ ë’¤, ê°€ì¥ ë¨¼ ê±°ë¦¬ë¥¼ ê°€ì§„ ë…¸ë“œë“¤ì˜ ê°œìˆ˜ë¥¼ ì¹´ìš´íŠ¸í•œë‹¤.

![image.png](../img/img13.png)

## ì½”ë“œ êµ¬í˜„

ğŸ’ŸÂ ì •ë‹µ ì½”ë“œ (ì§ì ‘ í•´ê²°í•œ ë°©ì‹)

```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] edge) {
			 // HashMapìœ¼ë¡œ ê·¸ë˜í”„ ìƒì„±
       Map<Integer, List<Integer>> graph = new HashMap<>();
			  // ê° ë…¸ë“œë§ˆë‹¤ ë¹ˆ ë¦¬ìŠ¤íŠ¸ ìƒì„± (ë…¸ë“œ ë²ˆí˜¸ê°€ 1ë¶€í„° ì‹œì‘í•˜ë¯€ë¡œ i = 1ë¶€í„° ì‹œì‘)
        for(int i = 1; i <= n; i++) {
            graph.put(i, new ArrayList<>());
        }
				// edge ë°°ì—´ì„ íƒìƒ‰í•˜ë©´ì„œ ì„œë¡œ ì—°ê²°ëœ ë…¸ë“œë“¤ì„ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
        for(int[] e: edge) {
            int a = e[0];
            int b = e[1];
            
						// ì–‘ë°©í–¥ ì—°ê²°ì´ë¯€ë¡œ aì—ë„ bë¥¼ ì¶”ê°€í•˜ê³ , bì—ë„ aì¶”ê°€
            graph.get(a).add(b);
            graph.get(b).add(a);
        }
				// 1ë²ˆ ë…¸ë“œì—ì„œ BFS í˜¸ì¶œ, distëŠ” ìµœë‹¨ ê±°ë¦¬ ì €ì¥í•  ë°°ì—´
        int[] dist = bfs(graph, n, 1);
        
        int max = 0;
				// ìµœë‹¨ ê±°ë¦¬ ë°°ì—´ì¸ dist ìˆœíšŒí•˜ë©´ì„œ ìµœëŒ€ê°’ ì°¾ê¸°
        for(int d : dist) {
            if(d > max) max = d;
        }
        
        int cnt = 0;
				// dist ë°°ì—´ ìˆœíšŒí•˜ë©´ì„œ ìœ„ì—ì„œ ì°¾ì€ ìµœëŒ€ê°’ê³¼ ê°™ì€ ê±°ë¦¬ë¥¼ ë°œê²¬í•˜ë©´ ì¹´ìš´íŒ…
        for(int d : dist) {
            if(d == max) cnt++;
        }
        return cnt;  
    }
    public int[] bfs(Map<Integer, List<Integer>> graph, int n, int startVertex) {
				// BFS íƒìƒ‰ì— ì‚¬ìš©í•  queue ìƒì„±
        Queue<Integer> queue = new LinkedList<>();
        int[] dist = new int[n+1]; // ìµœë‹¨ ê±°ë¦¬ë¥¼ ì €ì¥í•  ë°°ì—´ ì„ ì–¸, ë…¸ë“œ ë²ˆí˜¸ 1ë²ˆë¶€í„° ì‚¬ìš©(n+1)
        boolean[] visited = new boolean[n+1]; // ë°©ë¬¸ ì—¬ë¶€ ì €ì¥í•  ë°°ì—´ ì„ ì–¸
        
        queue.offer(startVertex); // íƒìƒ‰í•  ë…¸ë“œ íì— enqueue (offer ëŒ€ì‹  addë„ ì‚¬ìš© ê°€ëŠ¥)
        visited[startVertex] = true; // ë°©ë¬¸ ì²˜ë¦¬
        
				// queueê°€ empty ë  ë•Œê¹Œì§€ ë°˜ë³µ
        while(!queue.isEmpty()) {
					  // queueì—ì„œ dequeueí•´ì„œ í˜„ì¬ ë°©ë¬¸í•  ë…¸ë“œë¡œ ì„¤ì • (remove ëŒ€ì‹  poll ì‚¬ìš© ê°€ëŠ¥)
            int currentVertex = queue.remove(); 
						// í˜„ì¬ ë°©ë¬¸í•œ ë…¸ë“œì— ì—°ê²°ëœ ëª¨ë“  ì´ì›ƒ ë…¸ë“œë¥¼ íƒìƒ‰
            for(int nextVertex : graph.get(currentVertex)) {
                if(!visited[nextVertex]) {
                    visited[nextVertex] = true; // ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œë¼ë©´ ë°©ë¬¸ ì²˜ë¦¬
                    dist[nextVertex] = dist[currentVertex] + 1; // í˜„ì¬ ë…¸ë“œì˜ ê±°ë¦¬ + 1 ìˆ˜í–‰í•˜ì—¬ ê±°ë¦¬ ë°°ì—´ ê°±ì‹ 
                    queue.offer(nextVertex); // ë°©ë¬¸í•˜ì§€ ì•Šì€ ì¸ì ‘ ë…¸ë“œ íì— enqueue
                }
            }
        }
        return dist;
    }
}
```

ğŸ’ŸÂ ì˜¤ë‹µ ì½”ë“œ

```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] edge) {
       Map<Integer, List<Integer>> graph = new HashMap<>();
        for(int i = 0; i < n; i++) {
            graph.put(i, new ArrayList<>());
        }
        for(int[] e: edge) {
            int a = e[0];
            int b = e[1];
            
            graph.get(a).add(b);
            graph.get(b).add(a);
        }
        int[] dist = bfs(graph, n, 1);
        
        int max = 0;
        for(int d : dist) {
            if(d > max) max = d;
        }
        
        int cnt = 0;
        for(int d : dist) {
            if(d == max) cnt++;
        }
        return cnt;  
    }
    public int[] bfs(Map<Integer, List<Integer>> graph, int n, int startVertex) {
        Queue<Integer> queue = new LinkedList<>();
        int[] dist = new int[n+1];
        boolean[] visited = new boolean[n+1];
        
        queue.offer(startVertex);
        visited[startVertex] = true;
        
        while(!queue.isEmpty()) {
            int currentVertex = queue.remove();
            for(int nextVertex : graph.get(currentVertex)) {
                if(!visited[nextVertex]) {
                    visited[nextVertex] = true;
                    dist[nextVertex] = dist[currentVertex] + 1;
                    queue.offer(nextVertex);
                }
            }
        }
        return dist;
    }
}
```

- for(int i = 0; i < n; i++) {
  graph.put(i, new ArrayList<>());
  } // ê·¸ë˜í”„ì— 0ë²ˆ ë…¸ë“œê°€ ì—†ëŠ”ë° i = 0ë¶€í„° ì‹œì‘í•˜ì—¬ index ì˜¤ë¥˜ ë°œìƒ

## ë°°ìš°ê²Œ ëœ ì 

BFS í…œí”Œë¦¿ì„ ì™¸ì›Œì„œ ì‚¬ìš©í•˜ë‹¤ë³´ë‹ˆ, ë¬¸ì œì—ì„œ ì£¼ì–´ì§„ ë…¸ë“œ ë²ˆí˜¸ë¥¼ ê³ ë ¤í•˜ì§€ ì•Šê³  i = 0 ë¶€í„° ì…ë ¥í•˜ì—¬ index ì˜¤ë¥˜ê°€ ë°œìƒí–ˆë‹¤. ìì£¼ ë“±ì¥í•˜ë©´ì„œ ì–´ëŠì •ë„ í‹€ì´ ì •í•´ì ¸ ìˆê¸° ë•Œë¬¸ì— í…œí”Œë¦¿ì„ ì™¸ìš°ëŠ” ê²ƒë„ ì¤‘ìš”í•˜ì§€ë§Œ, ë¬¸ì œë§ˆë‹¤ ì ìš©í•˜ëŠ” ë°©ì‹ì´ ì¡°ê¸ˆì”© ë‹¤ë¥¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë¬¸ì œë¥¼ ê¼¼ê¼¼íˆ í™•ì¸í•˜ëŠ” ìŠµê´€ì´ í•„ìš”í•˜ë‹¤ëŠ” ì ì„ ê¹¨ë‹¬ì•˜ë‹¤.